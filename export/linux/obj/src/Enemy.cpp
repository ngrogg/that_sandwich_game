// Generated by Haxe 3.4.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Enemy
#include <Enemy.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_math_FlxVelocity
#include <flixel/math/FlxVelocity.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c595a05c1c7a687d_18_new,"Enemy","new",0x35d4571a,"Enemy.new","Enemy.hx",18,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_57_init,"Enemy","init",0xe0b09716,"Enemy.init","Enemy.hx",57,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_276_update,"Enemy","update",0xcf0e6f8f,"Enemy.update","Enemy.hx",276,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_287_kill,"Enemy","kill",0xe1ff3ba4,"Enemy.kill","Enemy.hx",287,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_302_decreaseHealth,"Enemy","decreaseHealth",0x29c5eb20,"Enemy.decreaseHealth","Enemy.hx",302,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_32_boot,"Enemy","boot",0xdc10e038,"Enemy.boot","Enemy.hx",32,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_36_boot,"Enemy","boot",0xdc10e038,"Enemy.boot","Enemy.hx",36,0xbda88996)

void Enemy_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_18_new)
HXLINE(  30)		this->StateSpawn = ::PlayState_obj::_level;
HXLINE(  45)		super::__construct(null(),null(),null());
            	}

Dynamic Enemy_obj::__CreateEmpty() { return new Enemy_obj; }

void *Enemy_obj::_hx_vtable = 0;

Dynamic Enemy_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Enemy_obj > _hx_result = new Enemy_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Enemy_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0b6ffd77) {
		if (inClassId<=(int)0x03a88228) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x03a88228;
		} else {
			return inClassId==(int)0x0b6ffd77;
		}
	} else {
		return inClassId==(int)0x25a685e0 || inClassId==(int)0x2e105115;
	}
}

 ::Enemy Enemy_obj::init(hx::Null< int >  __o_X,hx::Null< int >  __o_Y,hx::Null< Float >  __o_VelocityX,hx::Null< Float >  __o_VelocityY,::String Size){
int X = __o_X.Default(0);
int Y = __o_Y.Default(0);
Float VelocityX = __o_VelocityX.Default(0);
Float VelocityY = __o_VelocityY.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_c595a05c1c7a687d_57_init)
HXLINE(  60)		this->set_exists(true);
HXLINE(  61)		this->set_visible(true);
HXLINE(  62)		this->set_active(true);
HXLINE(  63)		this->set_solid(true);
HXLINE(  67)		if ((this->StateSpawn == (int)1)) {
HXLINE(  69)			this->Rspawn = (int)1;
            		}
HXLINE(  73)		if ((this->StateSpawn == (int)2)) {
HXLINE(  75)			this->Rspawn = ::flixel::FlxG_obj::random->_hx_int((int)1,(int)2,null());
            		}
HXLINE(  79)		if ((this->StateSpawn >= (int)3)) {
HXLINE(  81)			this->Rspawn = ::flixel::FlxG_obj::random->_hx_int((int)1,(int)4,null());
            		}
HXLINE(  86)		if ((this->Rspawn == (int)1)) {
HXLINE(  89)			 ::Dynamic _hx_tmp;
HXDLIN(  89)			if (hx::IsNull( Size )) {
HXLINE(  89)				_hx_tmp = HX_("assets/bile_burger.png",c3,de,45,58);
            			}
            			else {
HXLINE(  89)				_hx_tmp = Size;
            			}
HXDLIN(  89)			this->loadGraphic(_hx_tmp,null(),null(),null(),null(),null());
HXLINE( 104)			this->centerOffsets(null());
HXLINE( 105)			::Enemy_obj::_health = (int)1;
HXLINE( 106)			::Enemy_obj::Enemytype = (int)1;
            		}
HXLINE( 109)		bool _hx_tmp1;
HXDLIN( 109)		if ((this->Rspawn == (int)2)) {
HXLINE( 109)			_hx_tmp1 = (::Enemy_obj::position == (int)1);
            		}
            		else {
HXLINE( 109)			_hx_tmp1 = false;
            		}
HXDLIN( 109)		if (_hx_tmp1) {
HXLINE( 112)			 ::Dynamic _hx_tmp2;
HXDLIN( 112)			if (hx::IsNull( Size )) {
HXLINE( 112)				_hx_tmp2 = HX_("assets/pink_slime.png",46,93,8b,90);
            			}
            			else {
HXLINE( 112)				_hx_tmp2 = Size;
            			}
HXDLIN( 112)			this->loadGraphic(_hx_tmp2,null(),null(),null(),null(),null());
HXLINE( 127)			this->centerOffsets(null());
HXLINE( 128)			::Enemy_obj::_health = (int)1;
HXLINE( 129)			::Enemy_obj::Enemytype = (int)2;
            		}
HXLINE( 132)		bool _hx_tmp3;
HXDLIN( 132)		if ((this->Rspawn == (int)3)) {
HXLINE( 132)			_hx_tmp3 = (::Enemy_obj::position == (int)1);
            		}
            		else {
HXLINE( 132)			_hx_tmp3 = false;
            		}
HXDLIN( 132)		if (_hx_tmp3) {
HXLINE( 135)			 ::Dynamic _hx_tmp4;
HXDLIN( 135)			if (hx::IsNull( Size )) {
HXLINE( 135)				_hx_tmp4 = HX_("assets/worst_Wurst.png",00,9b,d9,29);
            			}
            			else {
HXLINE( 135)				_hx_tmp4 = Size;
            			}
HXDLIN( 135)			this->loadGraphic(_hx_tmp4,null(),null(),null(),null(),null());
HXLINE( 150)			this->centerOffsets(null());
HXLINE( 151)			::Enemy_obj::_health = (int)3;
HXLINE( 152)			::Enemy_obj::Enemytype = (int)3;
            		}
HXLINE( 155)		bool _hx_tmp5;
HXDLIN( 155)		if ((this->Rspawn == (int)4)) {
HXLINE( 155)			_hx_tmp5 = (::Enemy_obj::position == (int)1);
            		}
            		else {
HXLINE( 155)			_hx_tmp5 = false;
            		}
HXDLIN( 155)		if (_hx_tmp5) {
HXLINE( 157)			 ::Dynamic _hx_tmp6;
HXDLIN( 157)			if (hx::IsNull( Size )) {
HXLINE( 157)				_hx_tmp6 = HX_("assets/bagbandit.png",17,86,37,a2);
            			}
            			else {
HXLINE( 157)				_hx_tmp6 = Size;
            			}
HXDLIN( 157)			this->loadGraphic(_hx_tmp6,null(),null(),null(),null(),null());
HXLINE( 159)			this->centerOffsets(null());
HXLINE( 160)			::Enemy_obj::_health = (int)3;
HXLINE( 161)			::Enemy_obj::Enemytype = (int)4;
            		}
HXLINE( 164)		bool _hx_tmp7;
HXDLIN( 164)		if ((X == (int)0)) {
HXLINE( 164)			_hx_tmp7 = (Y != (int)0);
            		}
            		else {
HXLINE( 164)			_hx_tmp7 = true;
            		}
HXDLIN( 164)		if (_hx_tmp7) {
HXLINE( 166)			this->set_x(X);
HXLINE( 167)			this->set_y(Y);
HXLINE( 168)			this->velocity->set_x(VelocityX);
HXLINE( 169)			this->velocity->set_y(VelocityY);
HXLINE( 170)			Float _hx_tmp8 = ::Math_obj::abs(this->velocity->x);
HXDLIN( 170)			this->angularVelocity = (_hx_tmp8 + ::Math_obj::abs(this->velocity->y));
HXLINE( 172)			return hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE( 176)		::Enemy_obj::initial_velocity = (int)100;
HXLINE( 177)		::Enemy_obj::velmod = (int)0;
HXLINE( 180)		if ((this->Rspawn == (int)2)) {
HXLINE( 182)			 ::Dynamic _hx_tmp9 = hx::ClassOf< ::Enemy >();
HXDLIN( 182)			::Enemy_obj::initial_velocity = (::Enemy_obj::initial_velocity + (int)50);
            		}
HXLINE( 187)		if ((::Enemy_obj::position == (int)1)) {
HXLINE( 190)			if ((this->Rspawn != (int)3)) {
HXLINE( 193)				if ((::flixel::FlxG_obj::random->_hx_float(null(),null(),null()) < ((Float)0.5))) {
HXLINE( 195)					this->set_x(((int)-64 + this->offset->x));
HXLINE( 196)					 ::flixel::math::FlxPoint _hx_tmp10 = this->velocity;
HXDLIN( 196)					int _hx_tmp11 = (::Enemy_obj::initial_velocity + ::Enemy_obj::velmod);
HXDLIN( 196)					int _hx_tmp12 = ::flixel::FlxG_obj::random->_hx_int((int)15,(int)20,null());
HXDLIN( 196)					_hx_tmp10->set_x(((Float)_hx_tmp11 / (Float)((int)2 + (_hx_tmp12 * ::Enemy_obj::initial_velocity))));
            				}
            				else {
HXLINE( 202)					this->set_x((::flixel::FlxG_obj::width + this->offset->x));
HXLINE( 203)					 ::flixel::math::FlxPoint _hx_tmp13 = this->velocity;
HXDLIN( 203)					int _hx_tmp14 = -(::Enemy_obj::initial_velocity);
HXDLIN( 203)					Float _hx_tmp15 = (_hx_tmp14 + ((Float)::Enemy_obj::velmod / (Float)(int)2));
HXDLIN( 203)					int _hx_tmp16 = ::flixel::FlxG_obj::random->_hx_int((int)15,(int)20,null());
HXDLIN( 203)					_hx_tmp13->set_x((_hx_tmp15 - (_hx_tmp16 * ::Enemy_obj::initial_velocity)));
            				}
HXLINE( 208)				this->set_y(::flixel::FlxG_obj::random->_hx_int((int)0,(int)200,null()));
HXLINE( 209)				 ::flixel::math::FlxPoint _hx_tmp17 = this->velocity;
HXDLIN( 209)				Float _hx_tmp18 = ::flixel::FlxG_obj::random->_hx_float(((Float)0.7),((Float)1.2),null());
HXDLIN( 209)				_hx_tmp17->set_y((((_hx_tmp18 * ::Enemy_obj::initial_velocity) * (int)2) - ::Enemy_obj::initial_velocity));
            			}
            			else {
HXLINE( 216)				if ((::flixel::FlxG_obj::random->_hx_float(null(),null(),null()) < ((Float)0.5))) {
HXLINE( 218)					this->set_x(((int)-64 + this->offset->x));
HXLINE( 219)					 ::flixel::math::FlxPoint _hx_tmp19 = this->velocity;
HXDLIN( 219)					int _hx_tmp20 = ::Enemy_obj::initial_velocity;
HXDLIN( 219)					Float _hx_tmp21 = (_hx_tmp20 + ((Float)::Enemy_obj::velmod / (Float)(int)2));
HXDLIN( 219)					int _hx_tmp22 = ::flixel::FlxG_obj::random->_hx_int((int)1,(int)10,null());
HXDLIN( 219)					_hx_tmp19->set_x((_hx_tmp21 + (_hx_tmp22 * ::Enemy_obj::initial_velocity)));
            				}
            				else {
HXLINE( 225)					this->set_x((::flixel::FlxG_obj::width + this->offset->x));
HXLINE( 226)					 ::flixel::math::FlxPoint _hx_tmp23 = this->velocity;
HXDLIN( 226)					int _hx_tmp24 = -(::Enemy_obj::initial_velocity);
HXDLIN( 226)					Float _hx_tmp25 = (_hx_tmp24 + ((Float)::Enemy_obj::velmod / (Float)(int)2));
HXDLIN( 226)					int _hx_tmp26 = ::flixel::FlxG_obj::random->_hx_int((int)1,(int)10,null());
HXDLIN( 226)					_hx_tmp23->set_x((_hx_tmp25 - (_hx_tmp26 * ::Enemy_obj::initial_velocity)));
            				}
HXLINE( 230)				this->set_y(::flixel::FlxG_obj::random->_hx_int((int)0,(int)200,null()));
HXLINE( 231)				 ::flixel::math::FlxPoint _hx_tmp27 = this->velocity;
HXDLIN( 231)				Float _hx_tmp28 = ::flixel::FlxG_obj::random->_hx_float(((Float)0.7),((Float)1.2),null());
HXDLIN( 231)				_hx_tmp27->set_y((((_hx_tmp28 * ::Enemy_obj::initial_velocity) * (int)2) - ::Enemy_obj::initial_velocity));
            			}
            		}
HXLINE( 236)		if ((::Enemy_obj::position == (int)2)) {
HXLINE( 238)			this->set_x((((Float)::flixel::FlxG_obj::width / (Float)(int)2) - (int)40));
HXLINE( 239)			this->set_y((::flixel::FlxG_obj::height + (int)40));
HXLINE( 240)			 ::flixel::math::FlxPoint _hx_tmp29 = this->velocity;
HXDLIN( 240)			Float _hx_tmp30 = ((Float)::Enemy_obj::initial_velocity / (Float)(int)2);
HXDLIN( 240)			int _hx_tmp31 = ::flixel::FlxG_obj::random->_hx_int((int)15,(int)20,null());
HXDLIN( 240)			_hx_tmp29->set_x((_hx_tmp30 + (_hx_tmp31 * ::Enemy_obj::initial_velocity)));
HXLINE( 241)			 ::flixel::math::FlxPoint _hx_tmp32 = this->velocity;
HXDLIN( 241)			Float _hx_tmp33 = ::flixel::FlxG_obj::random->_hx_float(((Float)0.7),((Float)1.2),null());
HXDLIN( 241)			_hx_tmp32->set_y((((_hx_tmp33 * ::Enemy_obj::initial_velocity) * (int)2) - ::Enemy_obj::initial_velocity));
            		}
HXLINE( 246)		if ((::Enemy_obj::position == (int)3)) {
HXLINE( 248)			this->set_x(((Float)::flixel::FlxG_obj::width / (Float)(int)2));
HXLINE( 249)			this->set_y((::flixel::FlxG_obj::height + (int)40));
HXLINE( 250)			 ::flixel::math::FlxPoint _hx_tmp34 = this->velocity;
HXDLIN( 250)			Float _hx_tmp35 = ((Float)::Enemy_obj::initial_velocity / (Float)(int)2);
HXDLIN( 250)			int _hx_tmp36 = ::flixel::FlxG_obj::random->_hx_int((int)15,(int)20,null());
HXDLIN( 250)			_hx_tmp34->set_x((_hx_tmp35 + (_hx_tmp36 * ::Enemy_obj::initial_velocity)));
HXLINE( 251)			 ::flixel::math::FlxPoint _hx_tmp37 = this->velocity;
HXDLIN( 251)			Float _hx_tmp38 = ::flixel::FlxG_obj::random->_hx_float(((Float)0.7),((Float)1.2),null());
HXDLIN( 251)			_hx_tmp37->set_y((((_hx_tmp38 * ::Enemy_obj::initial_velocity) * (int)2) - ::Enemy_obj::initial_velocity));
            		}
HXLINE( 256)		if ((::Enemy_obj::position == (int)4)) {
HXLINE( 258)			this->set_x((((Float)::flixel::FlxG_obj::width / (Float)(int)2) + (int)40));
HXLINE( 259)			this->set_y((::flixel::FlxG_obj::height + (int)40));
HXLINE( 260)			 ::flixel::math::FlxPoint _hx_tmp39 = this->velocity;
HXDLIN( 260)			Float _hx_tmp40 = ((Float)-(::Enemy_obj::initial_velocity) / (Float)(int)2);
HXDLIN( 260)			int _hx_tmp41 = ::flixel::FlxG_obj::random->_hx_int((int)15,(int)20,null());
HXDLIN( 260)			_hx_tmp39->set_x((_hx_tmp40 + (_hx_tmp41 * ::Enemy_obj::initial_velocity)));
HXLINE( 261)			 ::flixel::math::FlxPoint _hx_tmp42 = this->velocity;
HXDLIN( 261)			Float _hx_tmp43 = ::flixel::FlxG_obj::random->_hx_float(((Float)0.7),((Float)1.2),null());
HXDLIN( 261)			_hx_tmp42->set_y((((_hx_tmp43 * ::Enemy_obj::initial_velocity) * (int)2) - ::Enemy_obj::initial_velocity));
            		}
HXLINE( 268)		 ::flixel::math::FlxPoint pt =  ::flixel::math::FlxPoint_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 269)		{
HXLINE( 269)			Float Y1 = ::Math_obj::floor((::flixel::FlxG_obj::height - (int)40));
HXDLIN( 269)			{
HXLINE( 269)				 ::flixel::math::FlxPoint _g = pt;
HXDLIN( 269)				_g->set_x((_g->x + ::Math_obj::floor((((Float)::flixel::FlxG_obj::width / (Float)(int)2) - (int)8))));
            			}
HXDLIN( 269)			{
HXLINE( 269)				 ::flixel::math::FlxPoint _g1 = pt;
HXDLIN( 269)				_g1->set_y((_g1->y + Y1));
            			}
            		}
HXLINE( 270)		::flixel::math::FlxVelocity_obj::moveTowardsPoint(hx::ObjectPtr<OBJ_>(this),pt,((::Math_obj::abs(this->velocity->y) + (int)1) * (int)2),null());
HXLINE( 272)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC5(Enemy_obj,init,return )

void Enemy_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_276_update)
HXLINE( 277)		bool _hx_tmp;
HXDLIN( 277)		if ((((int)this->touching & (int)(int)4369) > (int)0)) {
HXLINE( 277)			_hx_tmp = (((int)this->wasTouching & (int)(int)4369) <= (int)0);
            		}
            		else {
HXLINE( 277)			_hx_tmp = false;
            		}
HXDLIN( 277)		if (_hx_tmp) {
HXLINE( 279)			Float _hx_tmp1 = ::Math_obj::abs(this->velocity->x);
HXDLIN( 279)			this->angularVelocity = (_hx_tmp1 + ::Math_obj::abs(this->velocity->y));
            		}
HXLINE( 282)		this->super::update(elapsed);
            	}


void Enemy_obj::kill(){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_287_kill)
HXLINE( 288)		this->super::kill();
HXLINE( 290)		if ((this->frameWidth <= (int)32)) {
HXLINE( 292)			return;
            		}
HXLINE( 295)		int initial_velocity = (int)25;
HXLINE( 296)		int slot;
HXLINE( 297)		::String size;
            	}


void Enemy_obj::decreaseHealth(hx::Null< int >  __o_Amount){
int Amount = __o_Amount.Default(1);
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_302_decreaseHealth)
HXDLIN( 302)		 ::Dynamic _hx_tmp = hx::ClassOf< ::Enemy >();
HXDLIN( 302)		::Enemy_obj::_health = (::Enemy_obj::_health - Amount);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Enemy_obj,decreaseHealth,(void))

int Enemy_obj::initial_velocity;

int Enemy_obj::velmod;

int Enemy_obj::_health;

int Enemy_obj::Enemytype;

int Enemy_obj::position;


hx::ObjectPtr< Enemy_obj > Enemy_obj::__new() {
	hx::ObjectPtr< Enemy_obj > __this = new Enemy_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Enemy_obj > Enemy_obj::__alloc(hx::Ctx *_hx_ctx) {
	Enemy_obj *__this = (Enemy_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Enemy_obj), true, "Enemy"));
	*(void **)__this = Enemy_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Enemy_obj::Enemy_obj()
{
}

hx::Val Enemy_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { return hx::Val( init_dyn() ); }
		if (HX_FIELD_EQ(inName,"kill") ) { return hx::Val( kill_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"Rspawn") ) { return hx::Val( Rspawn ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"StateSpawn") ) { return hx::Val( StateSpawn ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"decreaseHealth") ) { return hx::Val( decreaseHealth_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Enemy_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"velmod") ) { outValue = ( velmod ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_health") ) { outValue = ( _health ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { outValue = ( position ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"Enemytype") ) { outValue = ( Enemytype ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"initial_velocity") ) { outValue = ( initial_velocity ); return true; }
	}
	return false;
}

hx::Val Enemy_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"Rspawn") ) { Rspawn=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"StateSpawn") ) { StateSpawn=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Enemy_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"velmod") ) { velmod=ioValue.Cast< int >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_health") ) { _health=ioValue.Cast< int >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { position=ioValue.Cast< int >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"Enemytype") ) { Enemytype=ioValue.Cast< int >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"initial_velocity") ) { initial_velocity=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Enemy_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("StateSpawn","\x8a","\xfe","\xfe","\xe7"));
	outFields->push(HX_HCSTRING("Rspawn","\xa9","\x34","\xaa","\x4a"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Enemy_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Enemy_obj,StateSpawn),HX_HCSTRING("StateSpawn","\x8a","\xfe","\xfe","\xe7")},
	{hx::fsInt,(int)offsetof(Enemy_obj,Rspawn),HX_HCSTRING("Rspawn","\xa9","\x34","\xaa","\x4a")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Enemy_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Enemy_obj::initial_velocity,HX_HCSTRING("initial_velocity","\x78","\xb8","\xf8","\x7c")},
	{hx::fsInt,(void *) &Enemy_obj::velmod,HX_HCSTRING("velmod","\x85","\x4c","\x4b","\x9d")},
	{hx::fsInt,(void *) &Enemy_obj::_health,HX_HCSTRING("_health","\x3b","\x3a","\x7d","\x6b")},
	{hx::fsInt,(void *) &Enemy_obj::Enemytype,HX_HCSTRING("Enemytype","\xe2","\xa8","\x21","\x64")},
	{hx::fsInt,(void *) &Enemy_obj::position,HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Enemy_obj_sMemberFields[] = {
	HX_HCSTRING("StateSpawn","\x8a","\xfe","\xfe","\xe7"),
	HX_HCSTRING("Rspawn","\xa9","\x34","\xaa","\x4a"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("kill","\x9e","\xdf","\x09","\x47"),
	HX_HCSTRING("decreaseHealth","\x9a","\x0b","\xcf","\x76"),
	::String(null()) };

static void Enemy_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Enemy_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Enemy_obj::initial_velocity,"initial_velocity");
	HX_MARK_MEMBER_NAME(Enemy_obj::velmod,"velmod");
	HX_MARK_MEMBER_NAME(Enemy_obj::_health,"_health");
	HX_MARK_MEMBER_NAME(Enemy_obj::Enemytype,"Enemytype");
	HX_MARK_MEMBER_NAME(Enemy_obj::position,"position");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Enemy_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Enemy_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Enemy_obj::initial_velocity,"initial_velocity");
	HX_VISIT_MEMBER_NAME(Enemy_obj::velmod,"velmod");
	HX_VISIT_MEMBER_NAME(Enemy_obj::_health,"_health");
	HX_VISIT_MEMBER_NAME(Enemy_obj::Enemytype,"Enemytype");
	HX_VISIT_MEMBER_NAME(Enemy_obj::position,"position");
};

#endif

hx::Class Enemy_obj::__mClass;

static ::String Enemy_obj_sStaticFields[] = {
	HX_HCSTRING("initial_velocity","\x78","\xb8","\xf8","\x7c"),
	HX_HCSTRING("velmod","\x85","\x4c","\x4b","\x9d"),
	HX_HCSTRING("_health","\x3b","\x3a","\x7d","\x6b"),
	HX_HCSTRING("Enemytype","\xe2","\xa8","\x21","\x64"),
	HX_HCSTRING("position","\xa9","\xa0","\xfa","\xca"),
	::String(null())
};

void Enemy_obj::__register()
{
	hx::Object *dummy = new Enemy_obj;
	Enemy_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("Enemy","\x28","\x82","\xa8","\x03");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Enemy_obj::__GetStatic;
	__mClass->mSetStaticField = &Enemy_obj::__SetStatic;
	__mClass->mMarkFunc = Enemy_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Enemy_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Enemy_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Enemy_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Enemy_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Enemy_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Enemy_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Enemy_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_32_boot)
HXDLIN(  32)		Enemytype = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_36_boot)
HXDLIN(  36)		position = ::PlayState_obj::_position;
            	}
}

